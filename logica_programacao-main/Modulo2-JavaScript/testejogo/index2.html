<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Jogo da Cobrinha</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

    :root{--bg:#0f1724;--panel:#0b1220;--accent:#16a34a;--muted:#94a3b8}
    *{box-sizing:border-box;font-family:Inter,Segoe UI,Arial,sans-serif}
    body{margin:0;min-height:100vh;display:grid;place-items:center;background:linear-gradient(180deg,#071226, #0b1220);color:#e6eef8}
    .wrap{width:760px;max-width:95%;display:grid;grid-template-columns:1fr 260px;gap:20px;align-items:start}
    canvas{background:#071127;border-radius:12px;display:block;width:100%;height:auto;box-shadow:0 8px 30px rgba(2,6,23,.7)}
    .panel{background:rgba(255,255,255,.02);padding:18px;border-radius:12px;min-height:140px}
    h1{font-size:18px;margin:0 0 8px}
    .controls{display:flex;gap:8px;flex-wrap:wrap}
    button{background:#0b1220;border:1px solid rgba(255,255,255,.04);padding:8px 12px;border-radius:10px;color:#e6eef8;cursor:pointer}
    .btn-primary{background:linear-gradient(90deg,#10b981,#059669);border:none;padding:10px 14px;font-weight:600}
    .score{font-size:14px;color:var(--muted);margin-top:8px}
    .kbd{display:inline-block;background:rgba(255,255,255,.03);padding:6px 8px;border-radius:6px;font-weight:600}
    footer{grid-column:1/-1;margin-top:12px;color:var(--muted);font-size:12px}
    @media (max-width:720px){.wrap{grid-template-columns:1fr}}
  </style>
</head>
<body>
  <div class="wrap">
    <div>
      <canvas id="game" width="520" height="520"></canvas>
      <footer>Use as setas ou WASD para controlar. Pressione <span class="kbd">Espaço</span> para pausar.</footer>
    </div>

    <div class="panel">
      <h1>Jogo da Cobrinha</h1>
      <div class="score">Pontuação: <strong id="score">0</strong></div>
      <div style="height:10px"></div>
      <div class="controls">
        <button id="start" class="btn-primary">Iniciar / Reiniciar</button>
        <button id="pause">Pausar</button>
        <button id="speedDown">— Velocidade</button>
        <button id="speedUp">+ Velocidade</button>
      </div>

      <div style="height:12px"></div>
      <div style="font-size:13px;color:var(--muted)">Controles rápidos</div>
      <ul style="margin:8px 0 0 18px;color:var(--muted)">
        <li>Setas / WASD — mover</li>
        <li>Espaço — pausar / retomar</li>
      </ul>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const startBtn = document.getElementById('start');
    const pauseBtn = document.getElementById('pause');
    const speedUp = document.getElementById('speedUp');
    const speedDown = document.getElementById('speedDown');
    const wrapCheckbox = document.getElementById('wrap');

    const GRID = 26; // número de células por linha
    const CELL = canvas.width / GRID; // tamanho de cada célula

    let snake, dir, food, loopId, speed, paused, score, gameOverFlag;

    function reset(){
      snake = [{x:12,y:12},{x:11,y:12},{x:10,y:12}];
      dir = {x:1,y:0};
      placeFood();
      speed = 8; // updates por segundo
      paused = false;
      score = 0;
      gameOverFlag = false;
      scoreEl.textContent = score;
      if(loopId) cancelAnimationFrame(loopId);
      lastTime = 0;
      tickInterval = 1000 / speed;
      run();
    }

    function placeFood(){
      while(true){
        const fx = Math.floor(Math.random()*GRID);
        const fy = Math.floor(Math.random()*GRID);
        if(!snake.some(s=>s.x===fx && s.y===fy)){
          food = {x:fx,y:fy};
          break;
        }
      }
    }

    function draw(){
      ctx.fillStyle = '#071127';
      ctx.fillRect(0,0,canvas.width,canvas.height);

      // grade
      ctx.strokeStyle = 'rgba(255,255,255,0.02)';
      ctx.lineWidth = 1;
      for(let i=0;i<=GRID;i++){
        ctx.beginPath();ctx.moveTo(i*CELL,0);ctx.lineTo(i*CELL,canvas.height);ctx.stroke();
        ctx.beginPath();ctx.moveTo(0,i*CELL);ctx.lineTo(canvas.width,i*CELL);ctx.stroke();
      }

      // comida
      ctx.fillStyle = '#ef4444';
      roundRect(ctx, food.x*CELL+4, food.y*CELL+4, CELL-8, CELL-8, 6);

      // cobra
      for(let i=0;i<snake.length;i++){
        const s = snake[i];
        const t = i===0 ? 1.0 : 0.85 - (i/snake.length)*0.5;
        ctx.fillStyle = `rgba(16,185,129,${t})`;
        roundRect(ctx, s.x*CELL+2, s.y*CELL+2, CELL-4, CELL-4, 6);
      }

      ctx.strokeStyle = 'rgba(255,255,255,0.04)';
      ctx.lineWidth = 2;
      ctx.strokeRect(0.5,0.5,canvas.width-1,canvas.height-1);

      // mensagem de game over
      if(gameOverFlag){
        ctx.fillStyle = '#ff0000';
        ctx.font = '32px "Press Start 2P", monospace';
        ctx.textAlign = 'center';
        ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2);
      }
    }

    function roundRect(ctx,x,y,w,h,r){
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
      ctx.fill();
    }

    function update(){
      const head = {x:snake[0].x + dir.x, y:snake[0].y + dir.y};

      if(wrapCheckbox.checked){
        head.x = (head.x + GRID) % GRID;
        head.y = (head.y + GRID) % GRID;
      } else {
        if(head.x < 0 || head.y < 0 || head.x >= GRID || head.y >= GRID){
          gameOver(); return;
        }
      }

      if(snake.some(s=>s.x===head.x && s.y===head.y)){
        gameOver(); return;
      }

      snake.unshift(head);

      if(head.x === food.x && head.y === food.y){
        score += 1;
        scoreEl.textContent = score;
        placeFood();
      } else {
        snake.pop();
      }
    }

    function gameOver(){
      paused = true;
      cancelAnimationFrame(loopId);
      gameOverFlag = true;
      draw();
    }

    let lastTime = 0;
    let tickInterval = 1000/8;
    function run(time){
      loopId = requestAnimationFrame(run);
      if(paused) { draw(); return; }
      if(!time) time = performance.now();
      const dt = time - lastTime;
      if(dt < tickInterval) return;
      lastTime = time;
      update();
      draw();
    }

    window.addEventListener('keydown', e=>{
      if(e.key === ' '){ paused = !paused; if(!paused) run(); e.preventDefault(); return; }
      const map = {
        ArrowUp:[0,-1],ArrowDown:[0,1],ArrowLeft:[-1,0],ArrowRight:[1,0],
        w:[0,-1],s:[0,1],a:[-1,0],d:[1,0]
      };
      const k = e.key.length===1? e.key.toLowerCase() : e.key;
      const dir2 = map[k];
      if(dir2){
        if(dir.x === -dir2[0] && dir.y === -dir2[1]) return;
        dir = {x:dir2[0], y:dir2[1]};
      }
    });

    startBtn.addEventListener('click', ()=>{ paused=false; reset(); });
    pauseBtn.addEventListener('click', ()=>{ paused = !paused; if(!paused) run(); pauseBtn.textContent = paused? 'Retomar' : 'Pausar'; });
    speedUp.addEventListener('click', ()=>{ if(speed<20) speed+=1; tickInterval = 1000/speed; });
    speedDown.addEventListener('click', ()=>{ if(speed>3) speed-=1; tickInterval = 1000/speed; });

    reset();

    let touchStart = null;
    canvas.addEventListener('touchstart', e=>{ const t=e.touches[0]; touchStart={x:t.clientX,y:t.clientY}; });
    canvas.addEventListener('touchmove', e=>{ if(!touchStart) return; const t=e.touches[0]; const dx = t.clientX - touchStart.x; const dy = t.clientY - touchStart.y; if(Math.abs(dx) > Math.abs(dy) && Math.abs(dx)>10){ dir = {x: dx>0?1:-1, y:0}; touchStart=null } else if(Math.abs(dy)>10){ dir = {x:0, y: dy>0?1:-1}; touchStart=null } e.preventDefault(); });

  </script>
</body>
</html>